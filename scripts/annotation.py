from mapping import mapping_main
from RSS import RSS_main
from report import report_main
from pathlib import Path
import pandas as pd
import argparse
from logger import custom_logger
from blast import blast_main
from map_genes import map_main
from extract_region import region_main

"""
Used Python packages:
    1. pandas
    2. openpyxl
"""

# Method for logging current states of the program.
logger = custom_logger(__name__)


def make_dir(dir: str) -> Path:
    """
    Ensures the specified directory exists by creating it if necessary. Checks if the directory exists, 
    and if it doesn't, creates the directory along with any necessary parent directories. Logs the creation 
    or existence of the directory. If an error occurs during the directory creation, raises an `OSError`.

    Args:
        dir (str): The path of the directory to be created.

    Returns:
        Path: The path of the created or existing directory.

    Raises:
        OSError: If the directory cannot be created due to a system-related error.
    """
    try:
        Path(dir).mkdir(parents=True, exist_ok=True)
        logger.info(f"Directory created or already exists: {dir}")
    except Exception as e:
        logger.error(f"Failed to create directory {dir}: {e}")
        raise OSError(f"Failed to create directory {dir}") from e
    return Path(dir)


def combine_df(mapping_tools: list, cell_type: str, input_dir: str, library: str, threads: int) -> pd.DataFrame:
    """
    Combines DataFrames generated by different mapping tools into a single DataFrame. Iterates over a list of 
    mapping tools (e.g., "bowtie", "bowtie2", "minimap2"), calling the `mapping_main` function to process the 
    input data. Concatenates the results from each tool into a single DataFrame. Removes duplicates based on 
    the columns ["start", "stop", "haplotype"]. Returns the resulting DataFrame with the index reset.

    Args:
        mapping_tools (list): List of mapping tools to use for sequence alignment.
        cell_type (str): The cell type to use in the mapping process (e.g., "TR", "IG").
        input_dir (str): Path to the directory containing input files.
        library (str): Path to the reference library file in FASTA format.
        threads (int): Number of CPU threads to use for parallel processing.

    Returns:
        pd.DataFrame: A combined DataFrame containing unique mapping entries across all specified tools.

    Raises:
        ValueError: If the input data is malformed or inconsistent across tools.
    """
    df = pd.DataFrame()
    for tool in mapping_tools:
        mapping_df = mapping_main(tool, cell_type, input_dir, library, threads)
        df = pd.concat([df, mapping_df])
        df["haplotype"] = df["file"].str.extract(r'_([^_]+)\.')[0]
    unique_combinations = df.drop_duplicates(
        subset=["start", "stop", "haplotype"]
    )
    return unique_combinations.reset_index(drop=True)


def write_report(df: pd.DataFrame, report: Path) -> None:
    """
    Saves a DataFrame to an Excel file at the specified path. Takes a DataFrame and writes it to an Excel 
    file (.xlsx) at the given path. Logs the success or failure of the operation. If an error occurs during 
    the file writing process, raises an `OSError`.

    Args:
        df (pd.DataFrame): The DataFrame to be saved.
        report (Path): The path where the Excel file should be saved.

    Returns:
        None

    Raises:
        OSError: If the file cannot be written to the specified path.
    """
    try:
        df.to_excel(report, index=False)
        logger.info(f"Report successfully saved to {report}")
    except Exception as e:
        logger.error(f"Failed to save the report to {report}: {e}")
        raise OSError(f"Failed to save the report to {report}") from e


def get_or_create(cell_type: str, annotation_folder: Path, mapping_tool: list, input_dir: str, library: str, threads: int) -> pd.DataFrame:
    """
    Retrieves or creates the annotation DataFrame. Checks if "report.xlsx" exists in the specified annotation folder. 
    If the file exists, loads the data into a DataFrame and returns it. If the file does not exist, generates the 
    DataFrame by calling `combine_df()` with the provided arguments, saves it as "report.xlsx" in the annotation folder, 
    and returns the newly created DataFrame.

    Args:
        cell_type (str): The cell type to use in the mapping process (e.g., "TR", "IG").
        annotation_folder (Path): The path to the folder where annotation files are stored.
        mapping_tool (list): List of mapping tools to use for sequence alignment.
        input_dir (str): Path to the directory containing input files.
        library (str): Path to the reference library file in FASTA format.
        threads (int): Number of CPU threads to use for parallel processing.

    Returns:
        pd.DataFrame: The annotation DataFrame, either loaded from an existing file or newly created.

    Raises:
        OSError: If the file cannot be read from or written to the specified path.
    """
    report = annotation_folder / "report.xlsx"
    if not report.exists():
        logger.info("The report.xlsx file does not exist! Creating it!")
        df = combine_df(mapping_tool, cell_type, input_dir, library, threads)
        write_report(df, report)
        return df
    else:
        try:
            df = pd.read_excel(report)
            logger.info(f"Loaded existing report from {report}")
            return df
        except Exception as e:
            logger.error(f"Failed to read the report from {report}: {e}")
            raise OSError(f"Failed to read the report from {report}") from e


def validate_directory(directory_path: str) -> str:
    """
    Validates that the specified directory exists. Checks if the provided path corresponds to an existing directory. 
    If the directory does not exist, raises an `argparse.ArgumentTypeError`.

    Args:
        directory_path (str): Path to the directory to validate.

    Returns:
        str: The validated directory path.

    Raises:
        argparse.ArgumentTypeError: If the directory does not exist.
    """
    if not Path(directory_path).is_dir():
        raise argparse.ArgumentTypeError(
            f"The directory {directory_path} does not exist. Try another directory!"
        )
    return directory_path


def validate_file(file_path: str) -> str:
    """
    Validates that the specified file exists. Checks if the provided path corresponds to an existing file. 
    If the file does not exist, raises an `argparse.ArgumentTypeError`.

    Args:
        file_path (str): Path to the file to validate.

    Returns:
        str: The validated file path.

    Raises:
        argparse.ArgumentTypeError: If the file does not exist.
    """
    if not Path(file_path).is_file():
        raise argparse.ArgumentTypeError(
            f"The file {file_path} does not exist. Try another file, please!"
        )
    return file_path


def validate_input(input_path: str) -> str:
    """
    Validates the input directory, ensuring it exists and contains FASTA files. Checks that the specified directory 
    exists and contains at least one FASTA file (with extensions .fasta, .fa, or .fna). If the directory is empty 
    or contains no FASTA files, raises an `argparse.ArgumentTypeError`.

    Args:
        input_path (str): Path to the input directory.

    Returns:
        str: The validated input directory path.

    Raises:
        argparse.ArgumentTypeError: If the directory is empty or contains no FASTA files.
    """
    input_path = Path(input_path)
    validate_directory(str(input_path))
    if not any(entry.is_file() for ext in ["*.fasta", "*.fa", "*.fna"] for entry in input_path.glob(ext)):
        raise argparse.ArgumentTypeError(
            f"The directory {input_path} is empty or does not contain any FASTA files!"
        )
    return str(input_path)


def validate_flanking_genes(value: str) -> list:
    """
    Validates and processes a list of flanking genes, ensuring they are uppercase and handles empty values. 
    Splits a comma-separated string of flanking genes, strips whitespace, converts them to uppercase, and 
    handles any empty values (represented by '-'). Ensures that the number of flanking genes is even; if not, 
    raises an `argparse.ArgumentTypeError`.

    Args:
        value (str): Comma-separated string of flanking genes.

    Returns:
        list: List of processed flanking genes.

    Raises:
        argparse.ArgumentTypeError: If the number of flanking genes is odd.
    """
    flanking_genes = [
        gene.strip().upper() if gene.strip() != '-' else '' for gene in value.split(',')
    ]
    if len(flanking_genes) % 2 == 1:
        raise argparse.ArgumentTypeError(
            f"The specified flanking genes: {flanking_genes} should be even numbers (e.g., 2, 4, 6, 8) rather than odd (e.g., 1, 3, 5)."
        )
    return flanking_genes


def argparser_setup(include_help: bool = True) -> argparse.ArgumentParser:
    """
    Configures the argument parser for the annotation tool. Sets up the command-line argument parser, defining 
    the required and optional arguments, mutually exclusive groups, and their validation logic. Supports customization 
    of the help option.

    Args:
        include_help (bool): Whether to include the help argument. Defaults to True.

    Returns:
        argparse.ArgumentParser: Configured argument parser ready for parsing input arguments.
    """
    parser = argparse.ArgumentParser(
        description='A tool for finding known and novel VDJ segments in certain data, with a library of choice.',
        formatter_class=argparse.ArgumentDefaultsHelpFormatter,
        add_help=include_help
    )

    required_group = parser.add_argument_group('Required Options')
    required_group.add_argument('-l', '--library', required=True, type=validate_file,
                                help='Path to the library file. Expected to be in FASTA format.')
    required_group.add_argument(
        '-r', '--receptor-type', required=True, type=str.upper, choices=['TR', 'IG'],
        help='Type of receptor to analyze: TR (T-cell receptor) or IG (Immunoglobulin).'
    )

    regions_or_assembly_group = parser.add_argument_group('Data Source Options',
                                                          'Select the data source: regions or assembly. These options are mutually exclusive.')
    data_choice = regions_or_assembly_group.add_mutually_exclusive_group(
        required=True
    )
    data_choice.add_argument('-i', '--input', type=validate_input,
                             help='Directory containing the extracted sequence regions in FASTA format, where VDJ segments can be found. Cannot be used with -f/--flanking-genes or -s/--species.')
    data_choice.add_argument('-a', '--assembly', type=validate_input,
                             help='Directory containing the assembly FASTA files. Must be used with -f/--flanking-genes and -s/--species.')

    assembly_options = parser.add_argument_group('Assembly-Specific Options',
                                                 'These options are required if -a/--assembly is chosen:')
    assembly_options.add_argument('-s', '--species', type=str,
                                  help='Species name, e.g., Homo sapiens. Required with -a/--assembly.')

    exclusive_group = parser.add_argument_group('Exclusive Options')
    exclusive_mutually_exclusive = exclusive_group.add_mutually_exclusive_group()
    exclusive_mutually_exclusive.add_argument('-f', '--flanking-genes', type=str,
                                              help='Comma-separated list of flanking genes, e.g., MGAM2,EPHB6. Add them as pairs. Required with -a/--assembly.')
    exclusive_mutually_exclusive.add_argument('--default', action='store_true',
                                              help='Use default settings. Cannot be used with -f/--flanking-genes or -c/--chromosomes.')

    optional_group = parser.add_argument_group('Optional Options')
    optional_group.add_argument('-o', '--output', type=str,
                                default='annotation',
                                help='Output directory for the results.')
    mapping_options = ['minimap2', 'bowtie', 'bowtie2']
    optional_group.add_argument('-m', '--mapping-tool', nargs='*',
                                choices=mapping_options, default=mapping_options,
                                help='Mapping tool(s) to use. Choose from: minimap2, bowtie, bowtie2. Defaults to all.')

    optional_group.add_argument('-t', '--threads', type=int,
                                required=False, default=8, help='Number of threads to run the analysis.')

    return parser


def main(args=None):
    """
    Main function for the annotation tool. Performs the following steps:

        1. Parses command-line arguments and sets up paths for input and output files.
        2. Validates input parameters and configures the environment based on the selected options.
        3. Creates necessary directories and initializes the annotation process.
        4. Executes the mapping and region extraction processes if assembly mode is selected:
           - Calls `map_main` to map flanking genes against the assembly.
           - Calls `region_main` to extract regions based on mapped genes.
        5. Retrieves or creates a DataFrame from existing or new mapping results:
           - Uses `get_or_create` to check for existing reports or generate new ones.
           - Calls `combine_df` to merge mapping results and remove duplicates.
        6. Runs BLAST operations to align sequences and generate results:
           - Calls `blast_main` to perform BLAST alignment on the combined DataFrame.
        7. Generates the final annotation report and RSS file:
           - Calls `report_main` to generate an Excel report summarizing the findings.
           - Calls `RSS_main` to produce an RSS feed if required.

    Args:
        args (list or None): Command-line arguments to parse. Defaults to None.

    Returns:
        None

    Raises:
        ValueError: If invalid arguments are passed to the main function.
        OSError: If any file or directory operation fails.
        subprocess.CalledProcessError: If a BLAST command or database creation fails.
    """
    update_args = argparser_setup()
    region_dir = "region"
    cwd = Path.cwd()

    if args is None:
        args = update_args.parse_args()
    elif isinstance(args, list):
        args = update_args.parse_args(args)
    elif not isinstance(args, argparse.Namespace):
        raise ValueError("Invalid arguments passed to the main function")

    if args.assembly:
        if not args.flanking_genes or not args.species:
            update_args.error(
                '-a/--assembly requires -f/--flanking-genes and -s/--species.'
            )
        args.species = args.species.capitalize() if args.species else None

    if args.input and (args.flanking_genes or args.species):
        update_args.error(
            '-i/--input cannot be used with -f/--flanking-genes or -s/--species.'
        )

    if args.input:
        region_dir = args.input

    annotation_folder = cwd / args.output
    make_dir(annotation_folder)

    if args.assembly:
        map_main(args.flanking_genes, args.assembly, args.species)
        region_main(args.flanking_genes, args.assembly)

    df = get_or_create(args.receptor_type, annotation_folder, args.mapping_tool,
                       region_dir, args.library, args.threads)

    blast_file = annotation_folder / "blast_results.xlsx"
    if not blast_file.exists():
        blast_main(df, blast_file, args.library)

    report_main(annotation_folder, blast_file, args.receptor_type, args.library)
    RSS_main()
    logger.info(
        f"Annotation process completed. Results are available in {args.output}."
    )


if __name__ == '__main__':
    main()
